{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to <code>si-units</code>","text":"<p>This package provides representations of quantities with SI units. It is written with flexibility in mind and is able to represent arbitrarily complex units. In addition to simple scalar quantities, it can be used to decorate any complex data type (numpy arrays, PyTorch tensors) to provide unit checks.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>si-units</code> from pypi using <code>pip</code>:</p> <pre><code>pip install si-units\n</code></pre>"},{"location":"#build-from-source","title":"Build from source","text":"<p>To build the code from source, you need the rust compiler.</p>"},{"location":"#maturin","title":"maturin","text":"<p>With maturin installed:</p> <pre><code>git clone https://github.com/itt-ustutt/quantity\ncd quantity/si-units\nmaturin build --release\n</code></pre> <p>You can then install the generated wheel (placed in <code>quantity/target/wheels</code>) into your Python environment.</p>"},{"location":"#uv","title":"uv","text":"<p>You can use uv to build the wheel:</p> <pre><code>git clone https://github.com/itt-ustutt/quantity\ncd quantity/si-units\nuv build\n</code></pre> <p>You can then install the generated wheel (placed in <code>dist/</code>) into your Python environment.</p>"},{"location":"#usage","title":"Usage","text":"Ideal gas pressure<pre><code>from si_units import *\ntemperature = 25.0 * CELSIUS\nvolume = 1.5 * METER**3\nmoles = 75.0 * MOL\npressure = moles * RGAS * temperature / volume\nprint(pressure)\n</code></pre> <pre><code>123.94785148011941 kPa\n</code></pre> <p>This also works with <code>numpy.ndarray</code>:</p> Using numpy<pre><code>from si_units import *\nimport numpy as np\nms = np.linspace(2.0, 4.0, 3) * METER\nsqms = ms**2\nprint(sqms)\n</code></pre> <pre><code>[4, 9, 16] m\u00b2\n</code></pre> <p>When you divide a quantity by its unit, the value (i.e. <code>float</code> for scalars or <code>numpy.ndarray[float]</code> for arrays) is returned. You can use this to convert units:</p> Unit conversion<pre><code>from si_units import MOL, METER, ANGSTROM, NAV\n\nmolar_density = 3000 * MOL / METER**3\nparticle_density = molar_density * NAV\nnparticles = 16_000\nvolume = nparticles / particle_density\n\n# make sure we actually have a volume\n# this checks the quantity (here length**3), not the actual unit\n# i.e. we could have used volume.has_unit(METER**3) for the same effect.\nassert volume.has_unit(METER**3), \"Something went wrong.\"\nprint(f'V = {volume / ANGSTROM**3:.2g} A^3')\n</code></pre> <pre><code>V = 8.9e+06 A^3\n</code></pre> <p>See Examples section for more use cases.</p>"},{"location":"api/","title":"Classes & Functions","text":""},{"location":"api/#si_units._core.SIObject","title":"<code>SIObject(value: float | Any, unit: list[int])</code>","text":"<p>Combination of value and unit.</p> <p>The value can be any Python object that can be used for arithmetic operations such as a float, numpy.ndarray or torch.tensor.</p> <p>When a SIObject is divided by its unit, the value is returned. This is usefull to convert units or when operations are needed that are not implemented for SIObject.</p> <p>Constructs a new quantity.</p> Don't use the default constructor <p>This constructor should not be used to construct a quantity. Instead, multiply the value (float or array of floats) by the appropriate unit. See example below.</p> PARAMETER DESCRIPTION <code>value</code> <p>The numerical value(s). Can be a scalar or an array such as a numpy.ndarray or a torch.tensor.</p> <p> TYPE: <code>float | Any</code> </p> <code>unit</code> <p>List of 7 exponents for SI base units.</p> <p> TYPE: <code>list[int]</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When unit has the wrong format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import si_units as si\n&gt;&gt;&gt; # don't do this:\n&gt;&gt;&gt; two_meters_init = si.SIObject(2.0, [1, 0, 0, 0, 0, 0, 0])\n&gt;&gt;&gt; # instead, do this:\n&gt;&gt;&gt; two_meters_mul = 2.0 * si.METER\n&gt;&gt;&gt; assert two_meters_init == two_meters_mul\n</code></pre> METHOD DESCRIPTION <code>cbrt</code> <p>Calculate the cubic root.</p> <code>sqrt</code> <p>Calculates the square root.</p> <code>has_unit</code> <p>Tests if the quantity has the same unit as the argument.</p> Source code in <code>si-units/src/si_units/_core.pyi</code> <pre><code>def __init__(self, value: float | Any, unit: list[int]) -&gt; None:\n    \"\"\"Constructs a new quantity.\n\n    Warning: Don't use the default constructor \n        This constructor should not be used to construct a quantity.\n        Instead, multiply the value (float or array of floats)\n        by the appropriate unit. See example below.\n\n    Args:\n        value:\n            The numerical value(s). Can be a scalar or an array\n            such as a numpy.ndarray or a torch.tensor.\n        unit: List of 7 exponents for SI base units.\n\n    Raises:\n        RuntimeError: When unit has the wrong format.\n\n    Examples:\n        &gt;&gt;&gt; import si_units as si\n        &gt;&gt;&gt; # don't do this:\n        &gt;&gt;&gt; two_meters_init = si.SIObject(2.0, [1, 0, 0, 0, 0, 0, 0])\n        &gt;&gt;&gt; # instead, do this:\n        &gt;&gt;&gt; two_meters_mul = 2.0 * si.METER\n        &gt;&gt;&gt; assert two_meters_init == two_meters_mul\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#si_units._core.SIObject.cbrt","title":"<code>cbrt() -&gt; Self</code>","text":"<p>Calculate the cubic root.</p> RETURNS DESCRIPTION <code>Self</code> <p>Cubic root of the quantity.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When exponents of units are not multiples of three.</p> <code>AttributeError</code> <p>When the inner data type has no 'cbrt' method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from si_units import METER\n&gt;&gt;&gt; volume = METER**3\n&gt;&gt;&gt; length = volume.cbrt()\n</code></pre> Source code in <code>si-units/src/si_units/_core.pyi</code> <pre><code>def cbrt(self) -&gt; Self:\n    \"\"\"Calculate the cubic root.\n\n    Returns:\n        Cubic root of the quantity.\n\n    Raises:\n        RuntimeError: When exponents of units are not multiples of three.\n        AttributeError: When the inner data type has no 'cbrt' method.\n\n    Examples:\n        &gt;&gt;&gt; from si_units import METER\n        &gt;&gt;&gt; volume = METER**3\n        &gt;&gt;&gt; length = volume.cbrt()\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#si_units._core.SIObject.sqrt","title":"<code>sqrt() -&gt; Self</code>","text":"<p>Calculates the square root.</p> RETURNS DESCRIPTION <code>Self</code> <p>Square root of the quantity.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When exponents of units are not multiples of two.</p> <code>AttributeError</code> <p>When the inner data type has no 'sqrt' method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from si_units import METER\n&gt;&gt;&gt; square = METER**2\n&gt;&gt;&gt; length = square.sqrt()\n</code></pre> Source code in <code>si-units/src/si_units/_core.pyi</code> <pre><code>def sqrt(self) -&gt; Self:\n    \"\"\"Calculates the square root.\n\n    Returns:\n        Square root of the quantity.\n\n    Raises:\n        RuntimeError: When exponents of units are not multiples of two.\n        AttributeError: When the inner data type has no 'sqrt' method.\n\n    Examples:\n        &gt;&gt;&gt; from si_units import METER\n        &gt;&gt;&gt; square = METER**2\n        &gt;&gt;&gt; length = square.sqrt()\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#si_units._core.SIObject.has_unit","title":"<code>has_unit(other: Self) -&gt; bool</code>","text":"<p>Tests if the quantity has the same unit as the argument.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Wheter the units of the compared quantities are the same or not.</p> Source code in <code>si-units/src/si_units/_core.pyi</code> <pre><code>def has_unit(self, other: Self) -&gt; bool:\n    \"\"\"Tests if the quantity has the same unit as the argument.\n\n    Args:\n        other: The quantity to compare to.\n\n    Returns:\n        Wheter the units of the compared quantities are the same or not.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#si_units._core.array","title":"<code>array(value: SIObject | list[SIObject]) -&gt; SIObject</code>","text":"<p>Build SIObject from scalar or list.</p> <p>When the input is a scalar, it is stored in an array with a single element.</p> PARAMETER DESCRIPTION <code>value</code> <p>Values to store. Must all have the same unit.</p> <p> TYPE: <code>SIObject | list[SIObject]</code> </p> RETURNS DESCRIPTION <code>SIObject</code> <p>The quantity with values stored within array,  even if value is given as a scalar.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the elements of value have different units.</p> Source code in <code>si-units/src/si_units/_core.pyi</code> <pre><code>def array(value: SIObject | list[SIObject]) -&gt; SIObject:\n    \"\"\"Build SIObject from scalar or list.\n\n    When the input is a scalar, it is stored in an array with a single element.\n\n    Args:\n        value: Values to store. Must all have the same unit.\n\n    Returns:\n        The quantity with values stored within array, \n            even if value is given as a scalar.\n\n    Raises:\n        RuntimeError: If the elements of value have different units.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#si_units._core.linspace","title":"<code>linspace(start: SIObject, end: SIObject, n: int) -&gt; SIObject</code>","text":"<p>Linearly spaced quantities.</p> PARAMETER DESCRIPTION <code>start</code> <p>Lowest value.</p> <p> TYPE: <code>SIObject</code> </p> <code>end</code> <p>Highest value.</p> <p> TYPE: <code>SIObject</code> </p> <code>n</code> <p>The (positive) number of points.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>SIObject</code> <p>Linearly spaced values with the same unit.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If start and end values are not scalars, if they don't have the same unit, or if n is not positive.</p> Source code in <code>si-units/src/si_units/_core.pyi</code> <pre><code>def linspace(start: SIObject, end: SIObject, n: int) -&gt; SIObject:\n    \"\"\"Linearly spaced quantities.\n\n    Args:\n        start: Lowest value.\n        end: Highest value.\n        n: The (positive) number of points.\n\n    Returns:\n        Linearly spaced values with the same unit.\n\n    Raises:\n        RuntimeError:\n            If start and end values are not scalars, if they don't have\n            the same unit, or if n is not positive.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#si_units._core.logspace","title":"<code>logspace(start: SIObject, end: SIObject, n: int) -&gt; SIObject</code>","text":"<p>Logarithmically spaced quantities.</p> PARAMETER DESCRIPTION <code>start</code> <p>Lowest value.</p> <p> TYPE: <code>SIObject</code> </p> <code>end</code> <p>Highest value.</p> <p> TYPE: <code>SIObject</code> </p> <code>n</code> <p>The (positive) number of points.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>SIObject</code> <p>Logarithmically spaced values with the same unit.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If start and end values are not scalars, if they don't have the same unit, or if n is not positive.</p> Source code in <code>si-units/src/si_units/_core.pyi</code> <pre><code>def logspace(start: SIObject, end: SIObject, n: int) -&gt; SIObject:\n    \"\"\"Logarithmically spaced quantities.\n\n    Args:\n        start: Lowest value.\n        end: Highest value.\n        n: The (positive) number of points.\n\n    Returns:\n        Logarithmically spaced values with the same unit.\n\n    Raises:\n        RuntimeError:\n            If start and end values are not scalars, if they don't have\n            the same unit, or if n is not positive.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"base/","title":"SI Base Units and Associated Constants (AC)","text":"<p>All capitalized entries in the <code>Unit</code> and <code>AC</code> (associated constants) columns from the table below can be imported:</p> Unit Symbol Quantity AC AC Name AC value SECOND \\(\\text{s}\\) time DVCS Hyperfine transition frequency of Cs \\(\\Delta\\nu_\\text{Cs}=9192631770~\\text{Hz}\\) METER \\(\\text{m}\\) length CLIGHT Speed of light \\(c=299792458~\\frac{\\text{m}}{\\text{s}}\\) KILOGRAM \\(\\text{kg}\\) mass PLANCK Planck constant \\(h=6.62607015\\times 10^{-34}~\\text{J}\\cdot\\text{s}\\) AMPERE \\(\\text{A}\\) electric current QE Elementary charge \\(e=1.602176634\\times 10^{-19}~\\text{C}\\) KELVIN \\(\\text{K}\\) thermodynamic temperature KB Boltzmann constant \\(k_\\text{B}=1.380649\\times 10^{-23}~\\frac{\\text{J}}{\\text{K}}\\) MOL \\(\\text{mol}\\) amount of substance NAV Avogadro constant \\(N_\\text{A}=6.02214076\\times 10^{23}~\\text{mol}^{-1}\\) CANDELA \\(\\text{cd}\\) luminous intensity KCD Luminous efficacy of \\(540~\\text{THz}\\) radiation \\(K_\\text{cd}=683~\\frac{\\text{lm}}{\\text{W}}\\)"},{"location":"base/#example","title":"Example","text":"<p><pre><code>from si_units import SECOND, DVCS\nprint(SECOND)\nprint(DVCS)\n</code></pre> <pre><code>1  s\n9.19263177 GHz\n</code></pre></p>"},{"location":"derived/","title":"Derived Units","text":"Unit Unit symbol Quantity Definition HERTZ \\(\\text{Hz}\\) frequency \\(\\text{s}^{-1}\\) NEWTON \\(\\text{N}\\) force; weight \\(\\text{kg}\\frac{\\text{m}}{\\text{s}^2}\\) PASCAL \\(\\text{Pa}\\) pressure; stress \\(\\frac{\\text{N}}{\\text{m}^2}\\) JOULE \\(\\text{J}\\) energy; work; heat \\(\\text{N}\\text{m}\\) WATT \\(\\text{W}\\) power; radiant flux \\(\\frac{\\text{J}}{\\text{s}}\\) COULOMB \\(\\text{C}\\) electric charge \\(\\text{A}\\text{s}\\) VOLT \\(\\text{V}\\) electrical potential difference \\(\\frac{\\text{W}}{\\text{A}}\\) FARAD \\(\\text{F}\\) capacitance \\(\\frac{\\text{C}}{\\text{V}}\\) OHM \\(\\text{\u03a9}\\) resistance; impedance; reactance \\(\\frac{\\text{V}}{\\text{A}}\\) SIEMENS \\(\\text{S}\\) electrical conductance \\(\\text{\u03a9}^{-1}\\) WEBER \\(\\text{Wb}\\) magnetic flux \\(\\text{V}\\text{s}\\) TESLA \\(\\text{T}\\) magnetic flux density \\(\\frac{\\text{Wb}}{\\text{m}^2}\\) HENRY \\(\\text{H}\\) inductance \\(\\frac{\\text{Wb}}{\\text{A}}\\)"},{"location":"derived/#additional-units","title":"Additional Units","text":"<p>For convenience, a number of commonly used units that are not directly combinations of SI base units is also included. These constants simplify the specification of properties, that are not given in SI units. However, as the representation of quantities is unique, they do not appear in formatted outputs.</p> Unit Unit symbol Quantity Definition ANGSTROM \\(\\text{\u00c5}\\) length \\(10^{-10}~\\text{m}\\) AMU \\(\\text{u}\\) mass \\(1.6605390671738466\\times 10^{-27}~\\text{kg}\\) AU \\(\\text{au}\\) length \\(149597870700~\\text{m}\\) BAR \\(\\text{bar}\\) pressure \\(10^5~\\text{Pa}\\) CALORIE \\(\\text{cal}\\) energy \\(4.184~\\text{J}\\) DAY \\(\\text{d}\\) time \\(86400~\\text{s}\\) DEBYE \\(\\text{De}\\) dipole moment \\(\\sqrt{10^{-19}~\\text{J\u00c5}^3}\\) DEGREES \\(^\\circ\\) angle \\(\\frac{\\pi}{180}~\\text{rad}\\) GRAM \\(\\text{g}\\) mass \\(10^{-3}~\\text{kg}\\) HOUR \\(\\text{h}\\) time \\(3600~\\text{s}\\) LITER \\(\\text{l}\\) volume \\(10^{-3}~\\text{m}^3\\) MINUTE \\(\\text{min}\\) time \\(60~\\text{s}\\) RADIANS \\(\\text{rad}\\) angle"},{"location":"derived/#additional-constants","title":"Additional Constants","text":"Constant Name Symbol Value G Gravitational constant \\(G\\) \\(6.6743\\times 10^{-11}~\\frac{\\text{m}^3}{\\text{kg}\\cdot\\text{s}^2}\\) RGAS Ideal gas constant \\(R=N_\\text{Av}k_\\text{B}\\) \\(8.31446261815324~\\frac{\\text{J}}{\\text{mol}\\cdot\\text{K}}\\)"},{"location":"derived/#example","title":"Example","text":"<p><pre><code>from si_units import RGAS, CALORIE\nfrom si_units import KILO # see prefixes\nprint(RGAS)\nKCAL = KILO * CALORIE\nprint(KCAL)\n</code></pre> <pre><code>8.31446261815324  J/mol/K\n4.184 kJ\n</code></pre></p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#how-it-works-values-and-units","title":"How it works: values and units","text":"<p>A quantity consists of two parts: a value and a unit. Internally, a unit is represented by a list of seven integers, one for each SI base unit:</p> <pre><code>unit: list[int] # [meter, kilogram, second, ampere, mol, kelvin, candela]\n</code></pre> <p>Each value in this list corresponds to the exponent of the respective unit. While it is possible to construct a <code>SIObject</code> by providing a value and a unit,  it is not recommendend because it is not very readable and prone to error: <pre><code>import si_units as si\nmass = si.SIObject(125.0, [0, 1, 0, 0, 0, 0, 0])\nprint(mass)\n</code></pre> <pre><code>125 kg\n</code></pre></p> <p>Instead, we can use one of the \"units\" (a <code>SIObject</code> with value one)  defined in the package and multiply it by the value.  Here we use <code>KILOGRAM</code> to yield the same result as above:</p> <p><pre><code>import si_units as si\nmass = 125.0 * si.KILOGRAM\nprint(mass)\n</code></pre> <pre><code>125 kg\n</code></pre></p> <p>For convenience and readability, <code>si_units</code> also defines prefixes. The following again yields the same result using the <code>KILO</code> prefix together with <code>GRAM</code>:</p> <p><pre><code>import si_units as si\nmass = 125.0 * si.KILO * si.GRAM\nprint(mass)\n</code></pre> <pre><code>125 kg\n</code></pre></p> <p>Prefixes and units can be used to define new types that you may want  to reuse across your code: <pre><code>import si_units as si\nMPA = si.MEGA * si.PASCAL\nKG_M3 = si.KILOGRAM / si.METER**3\nFS = si.FEMTO * si.SECOND\n...\n</code></pre></p>"},{"location":"examples/#unit-conversion","title":"Unit conversion","text":"<p>Consider the pressure of an ideal gas:</p> <pre><code>from si_units import *\ntemperature = 298.15 * KELVIN\nvolume = 1.5 * METER**3\nmoles = 75.0 * MOL\npressure = moles * RGAS * temperature / volume\nprint(pressure)\n</code></pre> <pre><code>123.94785148011941 kPa\n</code></pre> <p>Internally, all <code>SIObject</code>s are represented in base SI units. Dividing by a unit (including prefixes) yields the value which can be a  scalar or an array or tensor. This can be used to \"convert\" a quantity into a value of the desired unit:</p> <pre><code>import si_units as si\ntemperature = 298.15 * si.KELVIN\nvolume = 1.5 * si.METER**3\nmoles = 75.0 * si.MOL\npressure = moles * si.RGAS * temperature / volume\nprint('pressure / bar:   ', pressure / si.BAR)\nprint('pressure / mN/A^2:', pressure / (si.MILLI * si.NEWTON / si.ANGSTROM**2))\nprint('volume / l:       ', volume / si.LITER)\n</code></pre> <pre><code>pressure / bar:    1.2394785148011942\npressure / mN/A^2: 1.239478514801194e-12\nvolume / l:        1500.0\n</code></pre>"},{"location":"examples/#one-dimensional-array-constructors","title":"One-dimensional array constructors","text":"<p>There are several ways to construct a <code>SIObject</code> where the value is a one-dimensional array.</p> <pre><code>import si_units as si\n# from a list of SIObjects\ntemperatures = si.array([298.15 * si.KELVIN, 313.15 * si.KELVIN])\n# linearly spaced\nheights = si.linspace(15 * si.CENTI * si.METER, 15 * si.METER, 1000)\n# log-spaced\npressures = si.logspace(100 * si.KILO * si.PASCAL, 50 * si.BAR, 100)\n</code></pre> <p>For multi-dimensional arrays, first construct a <code>numpy.ndarray</code> of the desired shape and multiply it by an unit.</p>"},{"location":"examples/#gravitational-pull-of-the-moon-on-the-earth","title":"Gravitational pull of the moon on the earth","text":"<pre><code>import si_units as si\nmass_earth = 5.9724e24 * si.KILOGRAM\nmass_moon = 7.346e22 * si.KILOGRAM\ndistance = 383.398 * si.KILO * si.METER\nforce = si.G * mass_earth * mass_moon / distance**2\nprint(force)\n</code></pre> <pre><code>1.992075748302325e26  N\n</code></pre>"},{"location":"examples/#pressure-distribution-in-the-atmosphere","title":"Pressure distribution in the atmosphere","text":"<p>Using the barometric formula.  This example demonstrates how dimensioned arrays can be constructed  using <code>numpy.ndarray</code>s. </p> <pre><code>import si_units as si\nimport numpy as np\n\nz = np.linspace(1.0, 70.0e3, 10) * si.METER\ng = 9.81 * si.METER / si.SECOND**2\nm = 28.949 * si.GRAM / si.MOL\nt = 283.15 * si.KELVIN\np0 = si.BAR\npressure = p0 * np.exp((-z * m * g) / (si.RGAS * t))\n\n# dividing with the unit of an SIObject returns a numpy.ndarray\n# iteration is currently not implemented.\nfor zi, pi in zip(z / si.METER, pressure / (si.KILO * si.PASCAL)):\n    print(f'z = {zi:16.10f}   p = {pi:16.10f}')\n</code></pre> Output<pre><code>z =     1.0000000000   p =    99.9879378249\nz =  7778.6666666667   p =    39.1279560236\nz = 15556.3333333333   p =    15.3118163640\nz = 23334.0000000000   p =     5.9919235296\nz = 31111.6666666667   p =     2.3448000375\nz = 38889.3333333333   p =     0.9175830080\nz = 46667.0000000000   p =     0.3590747881\nz = 54444.6666666667   p =     0.1405155744\nz = 62222.3333333333   p =     0.0549875048\nz = 70000.0000000000   p =     0.0215180823\n</code></pre> <p>Alternatively, we could have used <code>si_units.linspace</code> instead of numpy: <pre><code>import si_units as si\n# instead of this\nz = np.linspace(1.0, 70.0e3, 10) * si.METER\n# we can also use this\nz = si.linspace(1.0 * si.METER, 70.0e3 * si.METER, 10)\n</code></pre></p>"},{"location":"examples/#using-numpy-or-torch-functions","title":"Using <code>numpy</code> or <code>torch</code> functions","text":"<p>Some functions work with methods or the equivalent numpy functions.</p> <pre><code>import si_units as si\nimport numpy as np\n\nsqm = si.METER**2\nprint(np.sqrt(sqm))\nprint(sqm.sqrt())   # this is equivalent\n</code></pre> <pre><code>1  m\n1  m\n</code></pre> <p>Some behaviour is not as you would expect. For example, when we change the above to an array, numpy will throw an exception: <pre><code>import si_units as si\nimport numpy as np\nsqm = np.array([1.0, 2.0]) * si.METER**2\nprint(np.sqrt(sqm))\nprint(sqm.sqrt())  # both calls raise an exception\n</code></pre> <pre><code>AttributeError: 'numpy.ndarray' object has no attribute 'sqrt'\n</code></pre></p> <p>In such a case, we can divide by the unit to return the inner data type, perform the operation to the value and the unit separately, and finally  multiply by the unit to get back a <code>SIObject</code>.</p> <p>For <code>torch.tensor</code>'s this is not an issue and the following works just  fine:</p> <pre><code>import si_units as si\nimport torch\nms = torch.tensor([2.0, 3.0, 4.0]) * si.METER\nsqms = ms**2\nprint(sqms)\nprint(sqms.sqrt())\n</code></pre> <pre><code>tensor([ 4.,  9., 16.]) m\u00b2\ntensor([2., 3., 4.]) m\n</code></pre>"},{"location":"prefixes/","title":"Prefixes","text":"<p>All units can be combined with the following prefixes (capitalized):</p> Prefix Prefix symbol Value Prefix Prefix symbol Value DECI \\(\\text{d}\\) \\(10^{-1}\\) DECA \\(\\text{da}\\) \\(10^{1}\\) CENTI \\(\\text{c}\\) \\(10^{-2}\\) HECTO \\(\\text{h}\\) \\(10^{2}\\) MILLI \\(\\text{m}\\) \\(10^{-3}\\) KILO \\(\\text{k}\\) \\(10^{3}\\) MICRO \\(\\text{\u00b5}\\) \\(10^{-6}\\) MEGA \\(\\text{M}\\) \\(10^{6}\\) NANO \\(\\text{n}\\) \\(10^{-9}\\) GIGA \\(\\text{G}\\) \\(10^{9}\\) PICO \\(\\text{p}\\) \\(10^{-12}\\) TERA \\(\\text{T}\\) \\(10^{12}\\) FEMTO \\(\\text{f}\\) \\(10^{-15}\\) PETA \\(\\text{P}\\) \\(10^{15}\\) ATTO \\(\\text{a}\\) \\(10^{-18}\\) EXA \\(\\text{E}\\) \\(10^{18}\\) ZEPTO \\(\\text{z}\\) \\(10^{-21}\\) ZETTA \\(\\text{Z}\\) \\(10^{21}\\) YOCTO \\(\\text{y}\\) \\(10^{-24}\\) YOTTA \\(\\text{Y}\\) \\(10^{24}\\) RONTO \\(\\text{r}\\) \\(10^{-27}\\) RONNA \\(\\text{R}\\) \\(10^{27}\\) QUECTO \\(\\text{q}\\) \\(10^{-30}\\) QUETTA \\(\\text{Q}\\) \\(10^{30}\\)"},{"location":"prefixes/#example","title":"Example","text":"<p><pre><code>from si_units import MICRO, SECOND, MEGA, PASCAL\ndt = 15 * MICRO * SECOND\nprint(dt)\n\nMPA = MEGA * PASCAL\npressure = 20 * MPA\nprint(pressure)\n</code></pre> <pre><code>15 \u00b5s\n20 MPa\n</code></pre></p>"}]}